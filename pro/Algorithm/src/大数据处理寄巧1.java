import java.util.ArrayList;

public class 大数据处理寄巧1 {

    /**
     * 题目背景：
     * 无符号整型的范围是0-4294967295，而int型的范围是-2147483648-2147483647，
     * 现在给定一个包含40亿个无符号整型的大文件
     * 明显的，其中不可能包含所有的无符号整型值
     *
     * 问题1：如何用较小的代价确定所有未出现的数
     * 问题2：如何用3KB的代价确定一个未出现的数
     * 问题3：如何使用有限几个变量确定一个未出现的数
     *
     */

    public static void main(String[] args) {

    }

    //问题1：如何用较小的代价确定所有未出现的数
    public static ArrayList<Integer> findMissing(int[] arr){
        /**
         * 方法概述：位图，
         *     1. 初始化一个长度为40亿个的bit类型数组，初始值都为0
         *     由于不是所有语言都能够实现bit，所以我们采用整型数组进行拼接
         *     4294967296是 2的32次方，每个int占用32个bit，所以只用创建134,217,728大小的int类型数组就行了（大约占用512MB
         *     同理也可以使用byte，空间一样的，其实无所谓
         *     遍历的时候访问到的数据进行置1，所有未被置1的地方就是未出现的数字
         */
        return null;
    }

    //问题2：如何使用3KB的空间找到一个未出现的数
    public static int findMissing2(int[] arr){

        /**
         * 合理利用这3KB的空间，3KB = 3*1024 = 3072Byte
         * 1int = 4Byte，3072Byte可以存放8192个int
         * 为了使得数据容易计算，一般采用2的次方，这里我们使用4096个int的数组
         * 对这个arr数组进行词频统计，将unsigned int范围中的4294967296分配到这个数组的空间中
         * 如果某个范围中所有的数都出现了，那这个int中存储的出现次数应该是1,048,576
         * 出现重复的也没有关系，因为这里多了一定意味着有地方少了，我们只需要找出一个低于这个数量的范围就行了
         *
         * 在这个范围内，再将值分成4096份进行词频统计，这样逐渐进行逼近就行了
         */
        return 0;
    }

    //问题3：如何使用有限几个变量确定一个未出现的数（以4个举例
    public static int findMissing3(int[] arr){

        /**
         * 总体思路与上述思路类似，只需要按照4进行词频划分就行
         * 也只需要遍历文件log4(2^32)次，也不是很多
         */
        return 0;
    }
}
