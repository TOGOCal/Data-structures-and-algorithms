public class 四边形不等式 {

    /**
     * 能使用四边形不等式的题目的几大特征：
     * 1.数据状况较为特殊（例如全是正数等
     * 2.区间划分
     * 3.有枚举行为
     * 4.行或者列不互相依赖（我真的可以先算出dp[i][j+1]，再算dp[i][j]）
     *  依赖别的项
     */

    /**
     * 问题背景：
     * 给定一个正数数组，代表完成一个项目需要的时间，现在有n个工人，每个工人同时只能完成一个项目
     * 当一个工人完成一个项目之后，他只能继续完成i+1的项目，
     * 也就是说，每个工人只能完成连续的项目，不能跳跃选取
     * 问最少需要多少时间才能完成所有项目
     */

    /**
     * 举例：
     * 项目 1 1 1 1 1 3 由3个工人完成
     * 1 1 1
     * 1 1
     * 3
     * 耗时3
     */

    /**
     * 动态规划方法：（普通）
     * dp[i][j]表示i个工人完成前j个项目所需要的时间
     * 依赖关系：
     * dp[i][j]位置的依赖：
     * dp[i-1][j] : 最后一个工人什么工作都不安排，时间就是与少了一个工人的情况相同
     *
     * dp[i-1][j-1] : 最后一个工人完成第j个项目，其余工人完成前j-1个项目
     * dp[i-1][j-2] : 最后一个工人完成第j-1和j项目，其余工人完成前j-2个项目
     * ...
     * 直到j=0；这个工人完成j个，其余工人什么工作都不安排
     */

    /**
     * 四边形不等式优化的动态规划：
     * 在枚举dp[i-1][j的变化]的时候，其实就是枚举第i个工人从哪里开始完成项目，做到j结束
     * 但是如果我们由方法提前确定dp[i+1][j] 多一个工人项目的完成情况，就可以确定i号工人选取哪个项目的上限
     * 也就是说，我们需要提前求出dp[i+1][j]的值，然后由dp[i+1][j]的值确定dp[i][j]的上限
     * 下线由d[i-1][j]确定
     *
     * 这就需要我们使用一种结构记录上述情况中dp[i-1][j-1] 和 dp[i+1][j]处理的时候的分割线在哪里
     *
     *    |   |                   |   |   |
     * 1 1 1 1 1 1   3         1 1 1 1 1 1 3
     * 三个人 分 前6个任务     四个人分前6个任务
     *
     * 0 - 6 范围 4个画家分 和 0 - 5范围三个画家分
     * 决定了 0 - 6范围三个画家分 的 枚举情况上下限
     */

    class Solution{

        public int minTime(int[] projects,int n){

            int[][] dp = new int[n+1][projects.length+1];

            //0个工人完成项目的情况
            for (int i = 0; i <= projects.length; i++) {

                dp[0][i] = -1;//不能完成
            }

            //多个工人完成0个项目的时间
            for (int i = 1; i <= n; i++) {

                dp[i][0] = 0;//0个项目，0个工人，时间0
            }

            //多个工人完成1个项目的时间
            for (int i = 1; i <= n; i++) {

                dp[i][1] = projects[0];//1个项目，i个工人，时间就是完成这个项目的时间
            }

            //一个工人完成多个项目的时间
            int sum = 0;
            for (int i = 1; i <= projects.length; i++) {

                sum += projects[i-1];
                dp[1][i] = sum;//一个工人完成多个项目，时间就是前i个项目的总和
            }

            //以上完成基本情况的填写=======================================================================================
            //接下来就是填表
            //由于依赖关系是依赖上面的左边，所以大方向是从上往下，从左往右
            for(int i = 2 ; i<= projects.length ; i++){

                //工人数量为1的情况已经填写，所以从2开始
                for(int j = 2 ; j<= n ; j++){

                    int min= dp[i-1][j];//最后一个工人什么都不做

                    int projectNum = i;
                    int thisWorkerTime = 0;
                    while(projectNum > 0){

                        thisWorkerTime += projects[projectNum-1];

                        projectNum--;//剩下的工人需要完成的工作时间

                        min = Math.min(
                                min,
                                Math.max(dp[i-1][projectNum],thisWorkerTime)
                        );

                        //小加速：工人数量不变的情况下，如果项目变少，时间一定减少（或者不变），但是另一个工人的时间一定变多

                        if(dp[j][projectNum] < thisWorkerTime){

                            break;
                        }
                    }

                    dp[i][j] = min;
                }
            }


            return dp[n][projects.length];

        }
    }

}
